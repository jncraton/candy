import stdlib
import stdio
import string
import fcntl

#ifdef _WIN32
import io
#endif

byte buf[256]
byte buf_start = 255
byte buf_len = 0
byte is_preprocessor_line = false
byte is_single_quoted = false
byte is_double_quoted = false
byte literal = false

int in_regular_code():
    return not is_double_quoted and 
           not is_single_quoted and 
           not is_preprocessor_line

void fill_buffer():
    buf_len = fread(buf, 1, 254, stdin)
    
    if not buf_len:
        exit(0)

byte get_byte(byte i):
    return buf[(byte)(buf_start + i)]

void set_byte(byte i, byte val):
    buf[(byte)(buf_start + i)] = val

byte read_next_byte():
    byte tmp[2]

    if not buf_len:
        return false
    
    buf_len--
    
    if fread(tmp, 1, 1, stdin):
        set_byte(-1, tmp[0])
        buf_len++
    
    buf_start++

    return true

int next_line_indent():
    for (byte i = 0; i < 254; i++):
        if (get_byte(i) == '\n' and get_byte(i+1) != '\n'):
            byte j
            
            for (j = 0; get_byte(i + j + 1) == ' '; j++)
            return j >> 2

    return false

int is_valid_name_char(byte c):
    return (c >= 48 and c <= 57) or 
           (c >= 65 and c <= 90) or 
           (c >= 97 and c <= 122) or 
           (c == '_')

int is_separator(byte c):
    return ( c == ';' or
             c == ',' or
             c == '&' or
             //c == '+' or
             //c == '-' or
             c == '*' or
             c == '/' or
             c == '>' or
             c == '<' or
             c == '|' or
             c == '{' or
             c == '}' or
             c == ' ' or
             c == '\n' or
             c == ':')

int buf_starts_with(char* keyword):
    for (int i = 0; i < strlen(keyword); i++):
        if get_byte(i) != keyword[i]:
            return false
        
    return true

int replace_keyword(char* keyword, char* replacement):
    if not in_regular_code():
        return false
    
    if is_valid_name_char(get_byte(-1)):
        return false
    
    if is_valid_name_char(get_byte(strlen(keyword))):
        return false
    
    if !buf_starts_with(keyword):
        return false
        
    printf(replacement)
    
    for (int i = 0; i < strlen(keyword) - 1; i++):
        read_next_byte()
    
    set_byte(0, replacement[strlen(replacement) - 1])
    
    return true

void automatic_semicolon():
    if (get_byte(0) == '\n' and 
        not is_preprocessor_line and
        not is_separator(get_byte(-1))):
        printf(";")

int main (int argc, char **argv):
    int line_pos = false
    byte open_braces = false
    byte previous_indent = false
    byte needs_closing_paren = false
    byte needs_closing_imp = false

    fill_buffer()

    #ifdef _WIN32
    // Work around newline replacement on Windows
    extern int fileno(FILE*)
    setmode(fileno(stdout), O_BINARY)
    #endif

    while (read_next_byte()):
        automatic_semicolon()

        if get_byte(0) == ':' and get_byte(1) == '\n':
            if needs_closing_paren:
                printf(")")
                needs_closing_paren = false
            printf(" {")
            open_braces++
        else if get_byte(0) == '\n':
            if needs_closing_imp:
                printf(".h\"")
                needs_closing_imp = false
            printf("\n")
        else if replace_keyword("if", "if ("):
            needs_closing_paren = true
        else if replace_keyword("import", "#include"):
            printf(" \"")
            read_next_byte()
            needs_closing_imp = true
            is_preprocessor_line = true
        else if get_byte(0) == '"' and !literal and !is_single_quoted and !is_double_quoted:
            printf("(\"")
        else if replace_keyword(" pass", " "):
            pass
        else if replace_keyword("not", "!"):
            pass
        else if replace_keyword("and", "&&"):
            pass
        else if replace_keyword("true", "(1)"):
            pass
        else if replace_keyword("false", "(0)"):
            pass
        else if replace_keyword("or", "||"):
            pass
        else if replace_keyword("byte", "unsigned char"):
            pass
        else:
            printf("%c", get_byte(0))
        
        if not is_preprocessor_line:
            // Handle closing brace insertion
            if get_byte(0) == '\n':
                while (open_braces and previous_indent > next_line_indent()):
                    for (byte i = 4; i < previous_indent << 2; i++):
                        printf(" ")

                    printf("}\n")
                    previous_indent--
                    open_braces--

                previous_indent = next_line_indent()
                #ifdef debug
                printf("// Next indent level: %d\n", previous_indent)
                #endif

            if (get_byte(0) == '"' and !literal and !is_single_quoted):
                if is_double_quoted:
                    printf(")")
            
        if get_byte(0) == '\n':
            is_preprocessor_line = false

        if (get_byte(0) == '#' and !(is_single_quoted || is_double_quoted)):
            is_preprocessor_line = true

        if (get_byte(0) == '\'' and !literal and !is_double_quoted):
            is_single_quoted = !is_single_quoted

        if (get_byte(0) == '"' and !literal and !is_single_quoted):
            is_double_quoted = !is_double_quoted
        
        if get_byte(0) == '\\' and !literal:
            literal = true
        else:
            literal = false
        
        line_pos +=1

    return false
